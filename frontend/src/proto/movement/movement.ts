// @generated by protobuf-ts 2.11.1 with parameter client_grpc1,generate_dependencies
// @generated from protobuf file "movement.proto" (package "movement", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message movement.Product
 */
export interface Product {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
    /**
     * @generated from protobuf field: string title = 2
     */
    title: string;
}
/**
 * @generated from protobuf message movement.Warehouse
 */
export interface Warehouse {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
}
/**
 * @generated from protobuf message movement.StockMovement
 */
export interface StockMovement {
    /**
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
    /**
     * @generated from protobuf field: string product_uuid = 2
     */
    productUuid: string;
    /**
     * @generated from protobuf field: string warehouse_uuid = 3
     */
    warehouseUuid: string;
    /**
     * @generated from protobuf field: movement.Product product = 4
     */
    product?: Product;
    /**
     * @generated from protobuf field: movement.Warehouse warehouse = 5
     */
    warehouse?: Warehouse;
    /**
     * @generated from protobuf field: string movement_type = 6
     */
    movementType: string; // STOCK_IN, STOCK_OUT, TRANSFER, ADJUSTMENT
    /**
     * @generated from protobuf field: int32 quantity = 7
     */
    quantity: number;
    /**
     * @generated from protobuf field: int32 previous_qty = 8
     */
    previousQty: number;
    /**
     * @generated from protobuf field: int32 new_qty = 9
     */
    newQty: number;
    /**
     * @generated from protobuf field: string reference_number = 10
     */
    referenceNumber: string;
    /**
     * @generated from protobuf field: string to_warehouse_uuid = 11
     */
    toWarehouseUuid: string;
    /**
     * @generated from protobuf field: string adjustment_reason = 12
     */
    adjustmentReason: string;
    /**
     * @generated from protobuf field: string notes = 13
     */
    notes: string;
    /**
     * @generated from protobuf field: string created_by = 14
     */
    createdBy: string;
    /**
     * @generated from protobuf field: string movement_date = 15
     */
    movementDate: string;
    /**
     * @generated from protobuf field: string created_at = 16
     */
    createdAt: string;
    /**
     * @generated from protobuf field: string updated_at = 17
     */
    updatedAt: string;
}
/**
 * @generated from protobuf message movement.WatchMovementsRequest
 */
export interface WatchMovementsRequest {
    /**
     * @generated from protobuf field: int32 limit = 1
     */
    limit: number; // 0 means no limit
}
/**
 * @generated from protobuf message movement.MovementUpdate
 */
export interface MovementUpdate {
    /**
     * @generated from protobuf field: repeated movement.StockMovement movements = 1
     */
    movements: StockMovement[];
    /**
     * @generated from protobuf field: string timestamp = 2
     */
    timestamp: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class Product$Type extends MessageType<Product> {
    constructor() {
        super("movement.Product", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Product>): Product {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.title = "";
        if (value !== undefined)
            reflectionMergePartial<Product>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Product): Product {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Product, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message movement.Product
 */
export const Product = new Product$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Warehouse$Type extends MessageType<Warehouse> {
    constructor() {
        super("movement.Warehouse", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Warehouse>): Warehouse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Warehouse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Warehouse): Warehouse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Warehouse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message movement.Warehouse
 */
export const Warehouse = new Warehouse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StockMovement$Type extends MessageType<StockMovement> {
    constructor() {
        super("movement.StockMovement", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "product_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "warehouse_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "product", kind: "message", T: () => Product },
            { no: 5, name: "warehouse", kind: "message", T: () => Warehouse },
            { no: 6, name: "movement_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "quantity", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "previous_qty", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "new_qty", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "reference_number", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "to_warehouse_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "adjustment_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "notes", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "created_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "movement_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "created_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "updated_at", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StockMovement>): StockMovement {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        message.productUuid = "";
        message.warehouseUuid = "";
        message.movementType = "";
        message.quantity = 0;
        message.previousQty = 0;
        message.newQty = 0;
        message.referenceNumber = "";
        message.toWarehouseUuid = "";
        message.adjustmentReason = "";
        message.notes = "";
        message.createdBy = "";
        message.movementDate = "";
        message.createdAt = "";
        message.updatedAt = "";
        if (value !== undefined)
            reflectionMergePartial<StockMovement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StockMovement): StockMovement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                case /* string product_uuid */ 2:
                    message.productUuid = reader.string();
                    break;
                case /* string warehouse_uuid */ 3:
                    message.warehouseUuid = reader.string();
                    break;
                case /* movement.Product product */ 4:
                    message.product = Product.internalBinaryRead(reader, reader.uint32(), options, message.product);
                    break;
                case /* movement.Warehouse warehouse */ 5:
                    message.warehouse = Warehouse.internalBinaryRead(reader, reader.uint32(), options, message.warehouse);
                    break;
                case /* string movement_type */ 6:
                    message.movementType = reader.string();
                    break;
                case /* int32 quantity */ 7:
                    message.quantity = reader.int32();
                    break;
                case /* int32 previous_qty */ 8:
                    message.previousQty = reader.int32();
                    break;
                case /* int32 new_qty */ 9:
                    message.newQty = reader.int32();
                    break;
                case /* string reference_number */ 10:
                    message.referenceNumber = reader.string();
                    break;
                case /* string to_warehouse_uuid */ 11:
                    message.toWarehouseUuid = reader.string();
                    break;
                case /* string adjustment_reason */ 12:
                    message.adjustmentReason = reader.string();
                    break;
                case /* string notes */ 13:
                    message.notes = reader.string();
                    break;
                case /* string created_by */ 14:
                    message.createdBy = reader.string();
                    break;
                case /* string movement_date */ 15:
                    message.movementDate = reader.string();
                    break;
                case /* string created_at */ 16:
                    message.createdAt = reader.string();
                    break;
                case /* string updated_at */ 17:
                    message.updatedAt = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StockMovement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        /* string product_uuid = 2; */
        if (message.productUuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.productUuid);
        /* string warehouse_uuid = 3; */
        if (message.warehouseUuid !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.warehouseUuid);
        /* movement.Product product = 4; */
        if (message.product)
            Product.internalBinaryWrite(message.product, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* movement.Warehouse warehouse = 5; */
        if (message.warehouse)
            Warehouse.internalBinaryWrite(message.warehouse, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string movement_type = 6; */
        if (message.movementType !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.movementType);
        /* int32 quantity = 7; */
        if (message.quantity !== 0)
            writer.tag(7, WireType.Varint).int32(message.quantity);
        /* int32 previous_qty = 8; */
        if (message.previousQty !== 0)
            writer.tag(8, WireType.Varint).int32(message.previousQty);
        /* int32 new_qty = 9; */
        if (message.newQty !== 0)
            writer.tag(9, WireType.Varint).int32(message.newQty);
        /* string reference_number = 10; */
        if (message.referenceNumber !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.referenceNumber);
        /* string to_warehouse_uuid = 11; */
        if (message.toWarehouseUuid !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.toWarehouseUuid);
        /* string adjustment_reason = 12; */
        if (message.adjustmentReason !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.adjustmentReason);
        /* string notes = 13; */
        if (message.notes !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.notes);
        /* string created_by = 14; */
        if (message.createdBy !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.createdBy);
        /* string movement_date = 15; */
        if (message.movementDate !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.movementDate);
        /* string created_at = 16; */
        if (message.createdAt !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.createdAt);
        /* string updated_at = 17; */
        if (message.updatedAt !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message movement.StockMovement
 */
export const StockMovement = new StockMovement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WatchMovementsRequest$Type extends MessageType<WatchMovementsRequest> {
    constructor() {
        super("movement.WatchMovementsRequest", [
            { no: 1, name: "limit", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<WatchMovementsRequest>): WatchMovementsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.limit = 0;
        if (value !== undefined)
            reflectionMergePartial<WatchMovementsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatchMovementsRequest): WatchMovementsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 limit */ 1:
                    message.limit = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatchMovementsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).int32(message.limit);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message movement.WatchMovementsRequest
 */
export const WatchMovementsRequest = new WatchMovementsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MovementUpdate$Type extends MessageType<MovementUpdate> {
    constructor() {
        super("movement.MovementUpdate", [
            { no: 1, name: "movements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StockMovement },
            { no: 2, name: "timestamp", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MovementUpdate>): MovementUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.movements = [];
        message.timestamp = "";
        if (value !== undefined)
            reflectionMergePartial<MovementUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MovementUpdate): MovementUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated movement.StockMovement movements */ 1:
                    message.movements.push(StockMovement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string timestamp */ 2:
                    message.timestamp = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MovementUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated movement.StockMovement movements = 1; */
        for (let i = 0; i < message.movements.length; i++)
            StockMovement.internalBinaryWrite(message.movements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string timestamp = 2; */
        if (message.timestamp !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message movement.MovementUpdate
 */
export const MovementUpdate = new MovementUpdate$Type();
/**
 * @generated ServiceType for protobuf service movement.MovementService
 */
export const MovementService = new ServiceType("movement.MovementService", [
    { name: "WatchMovements", serverStreaming: true, options: {}, I: WatchMovementsRequest, O: MovementUpdate }
]);
